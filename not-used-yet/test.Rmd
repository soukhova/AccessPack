---
title: "Testing function with tidy evaluation of variables"
output: html_document
---

Load packages:
```{r setup}
library(AccessPack)
library(dplyr)
library(ggplot2)
library(patchwork)
```

Second version of function with tidy evaluation:
*note* the following chunk has been added as a function, sp_avail2 in the R/ folder and is available in the package. 
```{r}
# #' The input is an OD-table with Origins, Destinations, Population, Jobs, and a pre-calculated impedance function f
# #'
# #' @param x A data frame with origin-destination information, including identifiers for origins, destinations, population, opportunities, and a pre-calculated impedance function
# #' @param o_id  The name of the column in data frame x that contains the unique origin identifiers
# #' @param d_id  The name of the column in data frame x that contains the unique destination identifiers
# #' @param pop   The name of the column in data frame x that contains the population
# #' @param opp   The name of the column in data frame x that contains the opportunities
# #' @param f     The name of the column in data frame x that contains the values of the impedance function
# #' @param alpha A number string with the name of the column in data frame x that contains the values of the impedance function
# #' @return A vector with the number of opportunities available to o_id from d_id
# #' @export sp_avail
# 
# sp_avail2 <- function(x, o_id, d_id, pop, opp, f, alpha = 1){
#   
#   o_id <- enquo(o_id)
#   d_id <- enquo(d_id)
#   pop <- enquo(pop)
#   opp <- enquo(opp)
#   f <- enquo(f)
#   
#   sum_pop <- x %>%
#     dplyr::distinct(!!o_id,
#                     .keep_all = TRUE) %>%
#     dplyr::mutate(sum_pop = (!!pop)^alpha) %>%
#     dplyr::pull(sum_pop) %>%
#     sum()
#   
#   x <- x %>%
#     dplyr::mutate(f_p = (!!pop)^alpha / sum_pop)
#   
#   sum_impedance <- x %>%
#     dplyr::group_by(!!d_id) %>%
#     dplyr::summarize(sum_impedance = sum(!!f))
#   
#   x <- x %>%
#     dplyr::left_join(sum_impedance,
#                      by = rlang::quo_text(d_id))
#   
#   x <- x %>%
#     dplyr::mutate(f_c = !!f / sum_impedance)
#   
#   sum_pa <- x %>%
#     dplyr::group_by(!!d_id) %>%
#     dplyr::summarize(sum_pa= sum(f_p * f_c))
#   
#   x <- x %>%
#     dplyr::left_join(sum_pa,
#                      by = rlang::quo_text(d_id))
#   
#   x <- x %>%
#     dplyr::mutate(f_t = (f_p * f_c) / sum_pa)
#   
#   x <- x %>%
#     dplyr::mutate(v_ij = !!opp * f_t)
#   
#   return(x$v_ij)
# }
```

Assign impedance function:
```{r}
beta <- 0.0015
od_table <- toy_od_table %>%
  mutate(f = exp(-beta * distance))
```

Test function:
```{r}
od_table_using2 <- od_table %>%
  mutate(V_ij = sp_avail2(., 
                          o_id = Origin, 
                          d_id = Destination, 
                          pop = Population, 
                          opp = Jobs,
                          f = f))
```

Verify that the sum of all jobs allocated is consistent with the total number of jobs:
```{r}
sum(od_table_using2$V_ij)
```

The total number of jobs is preserved.

Aggregate available jobs by origin:
```{r}
availability <- od_table_using2 %>%
  group_by(Origin) %>%
  summarize(avail_jobs = sum(V_ij))
availability
```

Now, lets use the first function (not using tidy evaluation)

Assign impedance function:
```{r}
beta <- 0.0015
od_table <- toy_od_table %>%
  mutate(f = exp(-beta * distance))
```

Test function:
```{r}
od_table_using1 <- od_table %>%
  mutate(V_ij = sp_avail(., 
                          o_id = Origin, 
                          d_id = "Destination", 
                          pop = Population, 
                          opp = Jobs,
                          f = f))
```

Are both dataframes equal?
```{r}
identical(od_table_using1, od_table_using2)
```
Yay they are!

How different are the run speeds? 

using the first sp_avail:
```{r}
system.time({ od_table_using1 <- od_table %>%
  mutate(V_ij = sp_avail(., 
                          o_id = Origin, 
                          d_id = "Destination", 
                          pop = Population, 
                          opp = Jobs,
                          f = f)) })
```
using the second sp_avail:
```{r}
system.time({ od_table %>%
  mutate(V_ij = sp_avail2(., 
                          o_id = Origin, 
                          d_id = Destination, 
                          pop = Population, 
                          opp = Jobs,
                          f = f)) })
```

Curious, the new function takes longer! 

Let's try a third:
```{r}
system.time({ od_table %>%
  mutate(V_ij = sp_avail3(., 
                          o_id = Origin, 
                          d_id = Destination, 
                          pop = Population, 
                          opp = Jobs,
                          f = f)) })


```

Yay ! Okay this third attempt is faster because I replaced "quo_text" with "as_name" (I believe as_name is preferred by rlang? not sure ) 

Now, does the third give the same results as the second?
```{r}
od_table_using3 <- od_table %>%
  mutate(V_ij = sp_avail3(., 
                          o_id = Origin, 
                          d_id = Destination, 
                          pop = Population, 
                          opp = Jobs,
                          f = f))

identical(od_table_using3, od_table_using2)
```

Oh it does, great!

## Testing TTS 16 data

Let's run the third function on the TTS 16 data

First, let's merge workers and job population to the OD tt
```{r}
od_ft <- od_ft_tt %>% merge(gtha_taz %>% select(GTA06, workers) %>% st_drop_geometry(),
                   by.x = "Origin", by.y="GTA06", all.x = T)

od_ft <- od_ft %>% merge(gtha_taz %>% select(GTA06, jobs) %>% st_drop_geometry(),
                   by.x = "Destination", by.y="GTA06", all.x = T)
```

next,  assign some beta value and calc impedence values:
```{r}
beta <- 0.0015
od_ft <- od_ft  %>%
  mutate(f = exp(-beta * travel_time))
```

Now calc the availability:
```{r}
od_ft_tt_using3 <- od_ft %>%
  mutate(V_ij = sp_avail3(., 
                          o_id = Origin, 
                          d_id = Destination, 
                          pop = workers, 
                          opp = jobs,
                          f = f))
```

Just in case... let's calcualte values using the other two functions and check if they are the same

```{r}
od_ft_tt_using1 <- od_ft %>%
  mutate(V_ij = sp_avail2(., 
                          o_id = Origin, 
                          d_id = Destination, 
                          pop = workers, 
                          opp = jobs,
                          f = f))

od_ft_tt_using1 <- od_ft %>%
  mutate(V_ij = sp_avail(., 
                          o_id = Origin, 
                          d_id = "Destination", 
                          pop = workers, 
                          opp = jobs,
                          f = f))

identical(od_ft_tt_using1,od_ft_tt_using2)
identical(od_ft_tt_using3,od_ft_tt_using2)
```
Great! Let's proceeds with function 3



Let's do some checks.

Verify that the sum of all jobs allocated is consistent with the total number of jobs:
```{r}
sum(od_ft_tt_using3$V_ij, na.rm=T)

sum_jobs <- od_ft_tt_using3 %>% group_by(Destination) %>% summarise(jobs = mean(jobs))
sum(sum_jobs$jobs, na.rm = T)
```
The total number of jobs is preserved.

Aggregate available jobs by origin:
```{r}
availability <- od_ft_tt_using3 %>%
  group_by(Origin) %>%
  summarize(avail_jobs = sum(V_ij),
            job_trips_from_Origin = sum(Persons))
availability
```
```{r}
# set null avail_jobs to 0
availability <- availability %>% mutate(avail_jobs = ifelse(is.na(avail_jobs), 0, avail_jobs))

#plot jobs vs trips taken - I'm curious
ggplot(availability, aes(x=avail_jobs, y=job_trips_from_Origin)) + geom_point()

```
Well; there are a lot of zones with no available jobs, a lot of zones with low available jobs and trips from origin, and there are very few origins with a high number of available jobs and high trips from origin. 



How would availability compare to conventional accessibility measure?

Let's assume an impedance function is simply a binary 45 mins or less; meaning any job which can be reach in more than 45 min is not considered in evaluating the job accessibility for each origin.  

```{r}
c_accessibility <- od_ft %>% filter(travel_time <= 45) %>% group_by(Destination) %>% summarise(c_access_jobs = sum(jobs, na.rm = T))

measures <- availability %>% merge(c_accessibility, by.x = "Origin" ,by.y = "Destination", all.x=T)

measures <- measures %>% mutate(c_access_jobs = ifelse(is.na(c_access_jobs), 0, c_access_jobs))
```

Now, we associate this object to a unique origins object to get the geometries.
```{r}
measures_i <- gtha_taz %>% merge(measures, by.x=c("GTA06"), by.y=c("Origin"), all.x=T) 
```

Plot origin conventional accessibility vs. availability
```{r fig.height=13}
plot_avail <- ggplot() +
  geom_sf(data = measures_i, 
          aes(fill= avail_jobs), color = NA) +
    scale_fill_distiller(palette = "Spectral", trans="sqrt")

plot_c_access <- ggplot() +
  geom_sf(data = measures_i, 
          aes(fill= c_access_jobs), color = NA) +
    scale_fill_distiller(palette = "Spectral", trans="sqrt")

plot_avail / plot_c_access
```


Hmm... not very telling. 

Let's filter in only Toronto  as we previously discussed

```{r}
#transform CRS
toronto_muni_bound <- st_transform(AccessPack::toronto_muni_bound, crs=32617)

#select only zones within Toronto Municipality
TO_measures_i <- measures_i %>%
  filter(st_intersects(., toronto_muni_bound, sparse = FALSE)[,1])

```

Plot origin conventional accessibility vs. availability for Toronto
```{r fig.height=13}
plot_avail <- ggplot() +
  geom_sf(data = TO_measures_i, 
          aes(fill= avail_jobs), color = NA) +
    scale_fill_distiller(palette = "Spectral",  trans = "sqrt")

plot_c_access <- ggplot() +
  geom_sf(data = TO_measures_i, 
          aes(fill= c_access_jobs), color = NA) +
    scale_fill_distiller(palette = "Spectral", trans = "sqrt")

plot_avail / plot_c_access
```


how about if normalized per number of workers from origin? (we don't have population of TAZ in this dataset)
```{r fig.height=13}
plot_avail <- ggplot() +
  geom_sf(data = TO_measures_i, 
          aes(fill= avail_jobs / workers), color = NA) +
    scale_fill_distiller(palette = "Spectral",  trans = "sqrt")

plot_c_access <- ggplot() +
  geom_sf(data = TO_measures_i, 
          aes(fill= c_access_jobs/ workers), color = NA) +
    scale_fill_distiller(palette = "Spectral", trans = "sqrt")

plot_avail / plot_c_access
```

